#!/usr/bin/env ruby

require 'json'
require 'octokit'

class PullRequest
  def initialize(repo:, pr:)
    @repo = repo
    @pr = pr
  end

  def pending?
    statuses.all? do |status|
      status['state'] == 'pending'
    end
  end

  def equals?(id:, ref:)
    [pr['head']['sha'], pr['id']] == [ref, id]
  end

  def to_json
    { ref: pr['head']['sha'], pr: pr['id'] }
  end

  private

  def statuses
    @statuses ||= Octokit.statuses(repo.name, sha).select do |status|
      status['context'] == 'concourseci'
    end
  end

  def sha
    pr['head']['sha']
  end
end

class Repository
  attr_reader :name

  def initialize(name:)
    @repo = repo
  end

  def pull_requests
    @pull_requests ||= Octokit.pulls(name, state: 'open', sort: 'updated', direction: 'desc').map do |pr|
      PullRequest.new(repo: self, pr: pr)
    end
  end

  def next_pull_request
    return if pull_requests.empty?

  end
end

def input
  @input ||= JSON.parse(ARGF.read).tap do |input|
    input['version'] ||= {}
  end
end

def json!(payload)
  puts JSON.generate(payload)
  exit
end

Octokit.connection_options[:ssl] = { verify: false } if ENV['http_proxy']
Octokit.auto_paginate = true

repo = Repository.new(name: input['source']['repo'])

current_pr = repo.pull_requests.find { |pr| pr.equals?(id: input['version']['pr'], sha: input['version']['ref']) }
json!([]) if current_pr && current_pr.pending?

most_recent = repo.pull_requests.first
if most_recent.pending?
  json!([most_recent.to_json])
else
  json!([])
end
